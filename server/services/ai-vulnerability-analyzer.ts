import OpenAI from "openai";
import type { Vulnerability } from "@shared/schema";

export interface VulnerabilityRiskScore {
  vulnerabilityId: number;
  riskScore: number; // 0-10 scale
  riskLevel: 'critical' | 'high' | 'medium' | 'low' | 'info';
  aiReasoning: string;
  exploitability: number; // 0-10
  businessImpact: number; // 0-10
  technicalSeverity: number; // 0-10
  urgency: 'immediate' | 'high' | 'medium' | 'low';
  remediationComplexity: 'simple' | 'moderate' | 'complex';
  contextualFactors: string[];
}

export interface PrioritizedVulnerabilityReport {
  scanId: number;
  totalVulnerabilities: number;
  riskDistribution: {
    critical: number;
    high: number;
    medium: number;
    low: number;
    info: number;
  };
  topPriorityVulnerabilities: VulnerabilityRiskScore[];
  recommendedActionPlan: string;
  executiveSummary: string;
}

export class AIVulnerabilityAnalyzer {
  private openai: OpenAI;

  constructor() {
    // the newest OpenAI model is "gpt-4o" which was released May 13, 2024. do not change this unless explicitly requested by the user
    this.openai = new OpenAI({ 
      apiKey: process.env.OPENAI_API_KEY || "sk-test-key"
    });
  }

  async prioritizeVulnerabilities(
    vulnerabilities: Vulnerability[], 
    targetUrl: string,
    scanContext?: { scanDepth: string; businessContext?: string }
  ): Promise<PrioritizedVulnerabilityReport> {
    if (vulnerabilities.length === 0) {
      return this.createEmptyReport(0);
    }

    try {
      // Analyze vulnerabilities in batches for better performance
      const riskScores = await this.analyzeVulnerabilityBatch(vulnerabilities, targetUrl, scanContext);
      
      // Sort by risk score (highest first)
      const sortedVulnerabilities = riskScores.sort((a, b) => b.riskScore - a.riskScore);
      
      // Generate executive summary and action plan
      const { executiveSummary, actionPlan } = await this.generateExecutiveSummary(
        sortedVulnerabilities, 
        targetUrl, 
        scanContext
      );

      return {
        scanId: vulnerabilities[0]?.scanId || 0,
        totalVulnerabilities: vulnerabilities.length,
        riskDistribution: this.calculateRiskDistribution(riskScores),
        topPriorityVulnerabilities: sortedVulnerabilities.slice(0, 10), // Top 10 highest risk
        recommendedActionPlan: actionPlan,
        executiveSummary
      };
    } catch (error) {
      console.error("Error in AI vulnerability prioritization:", error);
      return this.createFallbackReport(vulnerabilities);
    }
  }

  private async analyzeVulnerabilityBatch(
    vulnerabilities: Vulnerability[],
    targetUrl: string,
    scanContext?: { scanDepth: string; businessContext?: string }
  ): Promise<VulnerabilityRiskScore[]> {
    const prompt = this.buildAnalysisPrompt(vulnerabilities, targetUrl, scanContext);
    
    const response = await this.openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: `You are an expert cybersecurity analyst specializing in vulnerability risk assessment and prioritization. 
          Your task is to analyze web application vulnerabilities and provide detailed risk scoring to help security teams prioritize remediation efforts.
          
          Consider factors like:
          - Exploitability (ease of exploitation)
          - Business impact (data exposure, service disruption)
          - Technical severity (system compromise potential)
          - Attack vector complexity
          - Available exploits and proof-of-concepts
          - Environmental context
          
          Respond with JSON containing detailed risk analysis for each vulnerability.`
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.3, // Lower temperature for more consistent analysis
    });

    const result = JSON.parse(response.choices[0].message.content || '{"vulnerabilities": []}');
    return result.vulnerabilities || [];
  }

  private buildAnalysisPrompt(
    vulnerabilities: Vulnerability[],
    targetUrl: string,
    scanContext?: { scanDepth: string; businessContext?: string }
  ): string {
    const vulnSummary = vulnerabilities.map((v, idx) => 
      `${idx + 1}. ${v.type.toUpperCase()} - ${v.title}
         Endpoint: ${v.endpoint}
         Current Severity: ${v.severity}
         Parameter: ${v.parameter || 'N/A'}
         Description: ${v.description}
         Evidence: ${v.evidence || 'N/A'}`
    ).join('\n\n');

    return `Analyze these ${vulnerabilities.length} vulnerabilities found during a security scan of ${targetUrl}.

Context:
- Scan Depth: ${scanContext?.scanDepth || 'standard'}
- Business Context: ${scanContext?.businessContext || 'general web application'}
- Target: ${targetUrl}

Vulnerabilities to analyze:
${vulnSummary}

For each vulnerability, provide a comprehensive risk assessment with:
1. Risk Score (0-10 scale where 10 is maximum risk)
2. Updated Risk Level (critical/high/medium/low/info)
3. AI Reasoning (2-3 sentences explaining the risk assessment)
4. Exploitability Score (0-10, how easy to exploit)
5. Business Impact Score (0-10, potential business damage)
6. Technical Severity Score (0-10, technical impact)
7. Urgency Level (immediate/high/medium/low)
8. Remediation Complexity (simple/moderate/complex)
9. Contextual Factors (array of relevant risk factors)

Consider real-world attack scenarios, current threat landscape, and practical exploitation difficulty.

Return JSON format:
{
  "vulnerabilities": [
    {
      "vulnerabilityId": number,
      "riskScore": number,
      "riskLevel": "critical|high|medium|low|info",
      "aiReasoning": "string",
      "exploitability": number,
      "businessImpact": number,
      "technicalSeverity": number,
      "urgency": "immediate|high|medium|low",
      "remediationComplexity": "simple|moderate|complex",
      "contextualFactors": ["factor1", "factor2", ...]
    }
  ]
}`;
  }

  private async generateExecutiveSummary(
    prioritizedVulnerabilities: VulnerabilityRiskScore[],
    targetUrl: string,
    scanContext?: { scanDepth: string; businessContext?: string }
  ): Promise<{ executiveSummary: string; actionPlan: string }> {
    const topRisks = prioritizedVulnerabilities.slice(0, 5);
    const criticalCount = prioritizedVulnerabilities.filter(v => v.riskLevel === 'critical').length;
    const highCount = prioritizedVulnerabilities.filter(v => v.riskLevel === 'high').length;

    const prompt = `Generate an executive summary and action plan for this vulnerability assessment:

Target: ${targetUrl}
Total Vulnerabilities: ${prioritizedVulnerabilities.length}
Critical Risk: ${criticalCount}
High Risk: ${highCount}

Top 5 Risks:
${topRisks.map((v, idx) => 
  `${idx + 1}. Risk Score: ${v.riskScore}/10 - ${v.riskLevel.toUpperCase()}
     Reasoning: ${v.aiReasoning}
     Urgency: ${v.urgency}`
).join('\n\n')}

Provide:
1. Executive Summary (3-4 sentences for leadership)
2. Recommended Action Plan (prioritized steps for security team)

Format as JSON:
{
  "executiveSummary": "string",
  "actionPlan": "string"
}`;

    const response = await this.openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: "You are a cybersecurity consultant writing executive-level security reports. Be concise, actionable, and business-focused."
        },
        {
          role: "user",
          content: prompt
        }
      ],
      response_format: { type: "json_object" },
      temperature: 0.4,
    });

    const result = JSON.parse(response.choices[0].message.content || '{"executiveSummary": "", "actionPlan": ""}');
    return {
      executiveSummary: result.executiveSummary || "Security assessment completed with vulnerability findings requiring attention.",
      actionPlan: result.actionPlan || "Review and remediate identified vulnerabilities based on risk priority."
    };
  }

  private calculateRiskDistribution(riskScores: VulnerabilityRiskScore[]) {
    return {
      critical: riskScores.filter(v => v.riskLevel === 'critical').length,
      high: riskScores.filter(v => v.riskLevel === 'high').length,
      medium: riskScores.filter(v => v.riskLevel === 'medium').length,
      low: riskScores.filter(v => v.riskLevel === 'low').length,
      info: riskScores.filter(v => v.riskLevel === 'info').length,
    };
  }

  private createEmptyReport(scanId: number): PrioritizedVulnerabilityReport {
    return {
      scanId,
      totalVulnerabilities: 0,
      riskDistribution: { critical: 0, high: 0, medium: 0, low: 0, info: 0 },
      topPriorityVulnerabilities: [],
      recommendedActionPlan: "No vulnerabilities found. Continue regular security monitoring.",
      executiveSummary: "Security scan completed successfully with no vulnerabilities detected."
    };
  }

  private createFallbackReport(vulnerabilities: Vulnerability[]): PrioritizedVulnerabilityReport {
    // Create basic prioritization without AI when API fails
    const basicScores: VulnerabilityRiskScore[] = vulnerabilities.map((vuln, idx) => ({
      vulnerabilityId: vuln.id,
      riskScore: this.getBasicRiskScore(vuln.severity, vuln.type),
      riskLevel: vuln.severity as any,
      aiReasoning: `Basic assessment: ${vuln.type} vulnerability with ${vuln.severity} severity.`,
      exploitability: this.getBasicScore(vuln.type, 'exploitability'),
      businessImpact: this.getBasicScore(vuln.type, 'impact'),
      technicalSeverity: this.getBasicScore(vuln.severity, 'severity'),
      urgency: this.mapSeverityToUrgency(vuln.severity),
      remediationComplexity: this.getRemediationComplexity(vuln.type),
      contextualFactors: [vuln.type, vuln.severity, 'automated-assessment']
    }));

    return {
      scanId: vulnerabilities[0]?.scanId || 0,
      totalVulnerabilities: vulnerabilities.length,
      riskDistribution: this.calculateRiskDistribution(basicScores),
      topPriorityVulnerabilities: basicScores.sort((a, b) => b.riskScore - a.riskScore).slice(0, 10),
      recommendedActionPlan: "Review vulnerabilities by severity. Address critical and high-risk items first.",
      executiveSummary: `Security scan identified ${vulnerabilities.length} vulnerabilities requiring remediation.`
    };
  }

  private getBasicRiskScore(severity: string, type: string): number {
    const severityScores = { critical: 9, high: 7, medium: 5, low: 3, info: 1 };
    const typeModifiers = { sqli: 1, xss: 0.8, directory_traversal: 0.7 };
    
    const baseScore = severityScores[severity as keyof typeof severityScores] || 5;
    const modifier = typeModifiers[type as keyof typeof typeModifiers] || 0.5;
    
    return Math.min(10, Math.round(baseScore * modifier * 10) / 10);
  }

  private getBasicScore(factor: string, type: 'exploitability' | 'impact' | 'severity'): number {
    const scores = {
      exploitability: { sqli: 8, xss: 7, directory_traversal: 6, critical: 9, high: 7, medium: 5, low: 3 },
      impact: { sqli: 9, xss: 6, directory_traversal: 7, critical: 9, high: 7, medium: 5, low: 3 },
      severity: { critical: 10, high: 8, medium: 6, low: 4, info: 2 }
    };
    
    return scores[type][factor as keyof typeof scores[typeof type]] || 5;
  }

  private mapSeverityToUrgency(severity: string): 'immediate' | 'high' | 'medium' | 'low' {
    const mapping: Record<string, 'immediate' | 'high' | 'medium' | 'low'> = { 
      critical: 'immediate', 
      high: 'high', 
      medium: 'medium', 
      low: 'low', 
      info: 'low' 
    };
    return mapping[severity] || 'medium';
  }

  private getRemediationComplexity(type: string): 'simple' | 'moderate' | 'complex' {
    const complexity: Record<string, 'simple' | 'moderate' | 'complex'> = { 
      xss: 'simple', 
      sqli: 'moderate', 
      directory_traversal: 'moderate' 
    };
    return complexity[type] || 'moderate';
  }
}